<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dark PDF | Convert PDFs to Dark Mode | Offline</title>
  <style>
    :root {
      color-scheme: dark light;
    }

    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      text-align: center;
      font-family: Arial, sans-serif;
    }

    #fileInput {
      display: none;
    }

    input {
      padding: 10px;
      margin: 10px;
      border: none;
      border-radius: 4px;
    }

    #uploadContainer {
      display: block;
      width: 80vw;
      height: 70vh;
      margin: 20px auto auto auto;
      cursor: pointer;
      font-size: 10em;
      border: 2px dashed;
      border-radius: 4px;
      align-content: center;
    }

    #downloadBtn {
      display: none;
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 2em;
      border: none;
      cursor: pointer;
      background-color: transparent;
    }

    #pdfContainer {
      width: 90%;
      margin: auto;
    }

    canvas,
    img {
      width: 100%;
      border: 1px solid;
      border-radius: 4px;
      margin-bottom: 10px;
    }

    #progressContainer {
      display: none;
      width: 90%;
      max-width: 90%;
      padding: 10px;
      margin: 20px auto;
      text-align: center;
    }

    #progressBar {
      width: 0;
      height: 20px;
      line-height: 20px;
      background-color: dodgerblue;
      transition: width 0.3s ease-in-out;
    }

    #progressText {
      margin: 20px;
      font-weight: bold;
    }
  </style>
</head>

<body>
  <main>
    <h1>üëÅÔ∏è ‚ù§Ô∏è Dark PDF</h1>
    <div id="inputContainer">
      <input type="number" id="scaleFactor" placeholder="Scale Factor (1-5): 1" /> |
      <input type="number" id="startPage" placeholder="Start Page: 1" /> |
      <input type="number" id="endPage" placeholder="End Page: auto" /> |
      <input type="number" id="tolerance" placeholder="Color Limit (0-255): 0" />
      <input type="file" id="fileInput" multiple accept="application/pdf" />
      <label for="fileInput" id="uploadContainer">‚äï</label>
    </div>
    <div id="progressContainer">
      <div id="progressBar"></div>
      <div id="progressText">0/0</div>
    </div>
    <button id="downloadBtn">üíæ</button>
    <div id="pdfContainer"></div>
  </main>

  <script src="lib/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = "lib/pdf.worker.min.js";</script>
  <script src="lib/pdf-lib.min.js" defer></script>

  <script>
    const progressContainer = document.getElementById("progressContainer");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");

    const downloadBtn = document.getElementById("downloadBtn");
    const pdfContainer = document.getElementById("pdfContainer");
    const uploadContainer = document.getElementById("uploadContainer");

    const inputContainer = document.getElementById("inputContainer");
    const inputScaleFactor = document.getElementById("scaleFactor");
    const inputStartPage = document.getElementById("startPage");
    const inputEndPage = document.getElementById("endPage");
    const inputTolerance = document.getElementById("tolerance");

    /**
     * If multiple files selected:
     * - Don't display converted PDF in browser.
     * - Enable auto-downlod.
     */
    let multipleInput;

    document.getElementById("fileInput").onchange = handleUpload;

    document.body.ondrop = handleUpload;
    document.body.ondragover = (event) => event.preventDefault();

    function handleDownload(name, bytes) {
      if (!bytes) return;
      const blob = new Blob([bytes], { type: "application/pdf" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `${name} (Dark Mode).pdf`;
      link.click();
      downloadBtn.style.display = "none";
    }

    function handleUpload(event) {
      event.preventDefault();
      const files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
      multipleInput = files.length > 1;
      for (const file of files) handleFile(file);
    }

    function handleFile(file) {
      if (file.type !== "application/pdf") return;
      const fileReader = new FileReader();
      fileReader.onload = async function () {
        await renderPDF(file.name, new Uint8Array(this.result));
      };
      fileReader.readAsArrayBuffer(file);
    }

    function minmax(value, min, max) {
      return Math.min(Math.max((isNaN(value) ? 0 : value), isNaN(min) ? max : min), max);
    }

    async function renderPDF(fileName, pdfData) {
      const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
      const pdfDoc = await PDFLib.PDFDocument.create();

      const pageScale = minmax(inputScaleFactor.valueAsNumber, 1, 5);
      const pageStart = minmax(inputStartPage.valueAsNumber, 1, pdf.numPages);
      const pageEnd = minmax(inputEndPage.valueAsNumber, inputEndPage.valueAsNumber, pdf.numPages);
      const tLow = minmax(inputTolerance.valueAsNumber, 0, 255);
      const tHigh = 255 - tLow;

      if (pageEnd < pageStart) return;

      inputContainer.style.display = "none";
      progressContainer.style.display = "block";

      if (!multipleInput) {
        pdfContainer.innerHTML = "";
      }

      const canvas = document.createElement("canvas");
      const canvasContext = canvas.getContext("2d", { willReadFrequently: true });

      for (let i = pageStart; i <= pageEnd; i++) {
        progressBar.style.width = `${i / pageEnd * 100}%`;
        progressText.innerText = (i === pageEnd) ? "Finalizing..." : `${i}/${pageEnd}`;

        // Yield to the event loop to prevent UI freezing and allow GC
        await new Promise(resolve => requestAnimationFrame(resolve));

        const page = await pdf.getPage(i);

        // 1. Base viewport reflects the actual dimensions of the PDF page
        const baseViewport = page.getViewport({ scale: 1 });

        // 2. Render viewport reflects the resolution we process the image at.
        // We multiply the user's scale by the device's pixel ratio (or at least 2x)
        // to guarantee high-DPI text rendering, eliminating blur even at Scale 1.
        const renderScale = pageScale * Math.max(window.devicePixelRatio || 1, 2);
        const renderViewport = page.getViewport({ scale: renderScale });

        canvas.width = renderViewport.width;
        canvas.height = renderViewport.height;

        await page.render({ canvasContext, viewport: renderViewport }).promise;

        // Apply dark mode effect
        const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        if (tLow === 0) {
          for (let j = 0; j < data.length; j += 4) {
            data[j] = 255 - data[j] + 25;
            data[j + 1] = 255 - data[j + 1] + 25;
            data[j + 2] = 255 - data[j + 2] + 25;
          }
        } else {
          for (let j = 0; j < data.length; j += 4) {
            const r = data[j];
            const g = data[j + 1];
            const b = data[j + 2];
            if ((r <= tLow && g <= tLow && b <= tLow) || (r >= tHigh && g >= tHigh && b >= tHigh)) {
              data[j] = 255 - r + 25;
              data[j + 1] = 255 - g + 25;
              data[j + 2] = 255 - b + 25;
            }
          }
        }

        canvasContext.putImageData(imageData, 0, 0);
        const imgBlob = await new Promise((resolve) => {
          canvas.toBlob(resolve, "image/jpeg", 1);
        });
        const imgBytes = await imgBlob.arrayBuffer();
        const jpgImage = await pdfDoc.embedJpg(imgBytes);

        if (!multipleInput) {
          const img = document.createElement("img");
          img.src = URL.createObjectURL(imgBlob);
          pdfContainer.appendChild(img);
        }

        // 3. Keep the new PDF page the *exact same physical size* as the original page,
        // but draw our high-resolution JPEG into it!
        const newPage = pdfDoc.addPage([baseViewport.width, baseViewport.height]);
        newPage.drawImage(jpgImage, {
          x: 0, y: 0,
          width: baseViewport.width,
          height: baseViewport.height,
        });
        page.cleanup();
      }

      if (pdf.destroy) {
        pdf.destroy();
      }

      progressContainer.style.display = "none";

      const name = fileName.replace(/\.pdf$/i, "");
      const bytes = await pdfDoc.save();

      if (multipleInput) {
        handleDownload(name, bytes);
      } else {
        downloadBtn.style.display = "inline-block";
        downloadBtn.onclick = (_) => handleDownload(name, bytes);
      }
    }
  </script>
</body>

</html>
