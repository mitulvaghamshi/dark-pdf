<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charSet="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="author" content="Mitul Vaghamshi">
  <meta name="description" content="Convert PDF to dark mode - Offline.">

  <meta property="og:type" content="website">
  <meta property="og:title" content="Dark PDF Converter">
  <meta property="og:site_name" content="Dark PDF Converter">
  <meta property="og:description" content="Convert PDF to dark mode - Offline.">
  <meta property="og:url" content="https://mitulvaghamshi.github.io/dark-pdf">
  <meta property="og:image" content="https://mitulvaghamshi.github.io/dark-pdf/icon.webp">
  <meta property="og:image:alt" content="Website logo with red heart and white background.">
  <meta property="og:image:type" content="image/webp">
  <meta property="og:image:width" content="265">
  <meta property="og:image:height" content="265">

  <meta name="keywords" content="Dark PDF, PDF Converter, Dark Mode, PDF Reader, Easy PDF Converter, Offline, Free PDF Converter, On Device">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Dark PDF | Convert PDFs to Dark Mode | Offline">
  <meta name="twitter:description" content="Convert PDF to dark mode - offline and free.">
  <meta name="twitter:image" content="https://mitulvaghamshi.github.io/dark-pdf/icon.webp">
  <meta name="twitter:image:alt" content="Convert PDF to dark mode - offline and free">

  <link href="https://mitulvaghamshi.github.io/dark-pdf" rel="canonical">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Dark PDF">
  <link rel="apple-touch-icon" type="image/webp" href="icon.webp">

  <link rel="icon" type="image/webp" href="icon.webp">
  <link rel="shortcut icon" type="image/webp" href="icon.webp">

  <title>Dark PDF | Convert PDFs to Dark Mode | Offline</title>

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "name": "Dark PDF - Convert PDFs to Dark Mode.",
      "image": "https://mitulvaghamshi.github.io/dark-pdf/icon.webp",
      "url": "https://mitulvaghamshi.github.io/dark-pdf/",
      "priceRange": "Free",
      "description": "Convert PDF to dark mode - offline - free.",
      "potentialAction": {
        "@type": "ViewAction",
        "target": "https://mitulvaghamshi.github.io/dark-pdf/"
      }
    }
  </script>
  <style>
    :root {
      color-scheme: dark light;
    }

    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      text-align: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }

    #file-input {
      display: none;
    }

    input {
      padding: 10px;
    }

    #upload-container {
      display: block;
      width: 80vw;
      height: 70vh;
      margin: 20px auto auto auto;
      cursor: pointer;
      font-size: 10em;
      border: 2px dashed;
      border-radius: 4px;
      align-content: center;
    }

    #download-button {
      display: none;
      position: absolute;
      top: 10px;
      right: 10px;
      border: none;
      cursor: pointer;
      font-size: xx-large;
      background-color: transparent;
    }

    #preview-container {
      width: 100%;
    }

    img {
      width: 100%;
    }

    #progress-container {
      display: none;
      width: 100%;
      text-align: center;
    }

    #progress-bar {
      width: 0;
      height: 20px;
      line-height: 20px;
      background-color: royalblue;
      transition: width 0.3s ease-in-out;
    }

    #progress-text {
      margin: 10px;
      font-weight: bold;
    }
  </style>
</head>

<body>
  <main>
    <h1 id="app-title">Dark PDF Converter</h1>
    <div id="input-container">
      <input type="number" id="image-quality" placeholder="Image Quality (1-5): 1" />
      <input type="number" id="start-page" placeholder="Start Page: 1" />
      <input type="number" id="end-page" placeholder="End Page: Auto" />
      <input type="file" id="file-input" multiple accept="application/pdf" />
      <label for="file-input" id="upload-container">⊕</label>
    </div>
    <div id="progress-container">
      <div id="progress-bar"></div>
      <div id="progress-text">0/0</div>
    </div>
    <button id="download-button">⬇</button>
    <div id="preview-container"></div>
  </main>

  <script src="lib/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = "lib/pdf.worker.min.js";</script>
  <script src="lib/pdf-lib.min.js" defer></script>

  <script type="module">
    const appTitle = document.getElementById("app-title");
    const progressContainer = document.getElementById("progress-container");
    const progressBar = document.getElementById("progress-bar");
    const progressText = document.getElementById("progress-text");

    const downloadButton = document.getElementById("download-button");
    const previewContainer = document.getElementById("preview-container");
    const uploadContainer = document.getElementById("upload-container");

    const inputContainer = document.getElementById("input-container");
    const inputImageQuality = document.getElementById("image-quality");
    const inputStartPage = document.getElementById("start-page");
    const inputEndPage = document.getElementById("end-page");

    let multipleInput; // Disable browser preview and enable auto-download.

    document.getElementById("file-input").onchange = handleUpload;

    document.body.ondragover = (event) => event.preventDefault();
    document.body.ondrop = handleUpload;

    function handleDownload(name, bytes) {
      if (!bytes) return;

      const blob = new Blob([bytes], { type: "application/pdf" });

      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `${name} (Dark Mode).pdf`;
      link.click();

      downloadButton.style.display = "none";
    }

    function handleUpload(event) {
      event.preventDefault();

      const files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
      multipleInput = files.length > 1;

      for (const file of files) handleFile(file);
    }

    function handleFile(file) {
      if (file.type !== "application/pdf") return;

      const fileReader = new FileReader();
      fileReader.onload = async function () {
        await renderPDF(file.name, new Uint8Array(this.result));
      };
      fileReader.readAsArrayBuffer(file);
    }

    function clamp(value, min, max) {
      return Math.min(Math.max((isNaN(value) ? 0 : value), isNaN(min) ? max : min), max);
    }

    async function renderPDF(fileName, pdfData) {
      const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
      const pdfDoc = await PDFLib.PDFDocument.create();

      // Clamp user inputs within a valid range.
      const pageScale = clamp(inputImageQuality.valueAsNumber, 1, 5);
      const pageStart = clamp(inputStartPage.valueAsNumber, 1, pdf.numPages);
      const pageEnd = clamp(inputEndPage.valueAsNumber, inputEndPage.valueAsNumber, pdf.numPages);

      if (pageEnd < pageStart) return;

      appTitle.innerText = fileName;
      inputContainer.style.display = "none";
      progressContainer.style.display = "block";

      if (!multipleInput) {
        previewContainer.innerHTML = "";
      }

      const canvas = document.createElement("canvas");
      const canvasContext = canvas.getContext("2d", { willReadFrequently: true });

      for (let i = pageStart; i <= pageEnd; i++) {
        progressBar.style.width = `${i / pageEnd * 100}%`;
        progressText.innerText = (i === pageEnd) ? "Finalizing..." : `Processed ${i} of ${pageEnd} pages`;

        // Yield to the event loop to prevent UI freezing and allow GC
        await new Promise(resolve => requestAnimationFrame(resolve));

        const page = await pdf.getPage(i);

        // Base viewport reflects the actual dimensions of the PDF page
        const baseViewport = page.getViewport({ scale: 1 });

        // Render viewport reflects the resolution we process the image at.
        // We multiply the user's scale by the device's pixel ratio (or at least 2x)
        // to guarantee high-DPI text rendering, eliminating blur even at Scale 1.
        const renderScale = pageScale * Math.max(window.devicePixelRatio || 1, 2);
        const renderViewport = page.getViewport({ scale: renderScale });

        canvas.width = renderViewport.width;
        canvas.height = renderViewport.height;

        await page.render({ canvasContext, viewport: renderViewport }).promise;

        const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        // Apply the dark mode effect by calculating the "colorfulness" of each pixel (Chroma).
        // Pure grayscale pixels (text or background) have a chroma of 0.
        // If a pixel is close to grayscale (below the color limit), invert it.
        // This prevents vivid and colorful image pixels from being inverted!
        for (let j = 0; j < data.length; j += 4) {
          const r = data[j];
          const g = data[j + 1];
          const b = data[j + 2];

          if (Math.max(r, g, b) - Math.min(r, g, b) <= 0) {
            data[j] = 255 - r + 25;
            data[j + 1] = 255 - g + 25;
            data[j + 2] = 255 - b + 25;
          }
        }

        canvasContext.putImageData(imageData, 0, 0);

        const imgBlob = await new Promise((resolve) => {
          canvas.toBlob(resolve, "image/jpeg", 0.9);
        });
        const imgBytes = await imgBlob.arrayBuffer();
        const jpgImage = await pdfDoc.embedJpg(imgBytes);

        if (!multipleInput) {
          const img = new Image();
          img.src = URL.createObjectURL(imgBlob);
          previewContainer.appendChild(img);
        }

        // Keep the new PDF page the *exact same physical size* as the original page,
        // but draw our high-resolution JPEG into it!
        const newPage = pdfDoc.addPage([baseViewport.width, baseViewport.height]);
        newPage.drawImage(jpgImage, {
          x: 0, y: 0,
          width: baseViewport.width,
          height: baseViewport.height,
        });

        page.cleanup();
      }

      if (pdf.destroy) {
        pdf.destroy();
      }

      progressContainer.style.display = "none";

      const name = fileName.replace(/\.pdf$/i, "");
      const bytes = await pdfDoc.save();

      if (multipleInput) {
        handleDownload(name, bytes);
      } else {
        downloadButton.style.display = "inline-block";
        downloadButton.onclick = (_) => handleDownload(name, bytes);
      }
    }
  </script>
</body>

</html>
